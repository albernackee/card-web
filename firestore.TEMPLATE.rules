//When you update this file, also run 'npm run test:security' to verify all tests pass
rules_version = '2'
service cloud.firestore {
  match /databases/{database}/documents {

    function basePermissions() {
      //Note that this is duplicated in src/reducers/user.js
      return {
        'admin': false,
        'viewApp': true,
        'edit': false,
        'viewUnpublished': false,
        'comment': false,
        'star': false,
        'markRead': false,
        'modifyReadingList': false,
      }
    }

    function baseUserTypeAnonymousPermissions() {
      //Note that this is duplicated in src/reducers/user.js
      let rules = {
        'star': true,
        'markRead': true,
        'modifyReadingList': true,
      };
       //Should return if the user is AT LEAST anonymous
      return loggedIn() ? rules : {};
    }

    function baseUserTypeSignedInPermissions() {
      //Note that this is duplicated in src/reducers/user.js
      let rules = {
        'comment': true,
      };
      return loggedIn() && !isAnonymous() ? rules : {};
    }

    function userMatchesDomain() {
      //inject here:domain
      return loggedIn() && !isAnonymous() && request.auth.token.email.lower().split('@')[1] == domain;
    }

    function userTypeAllPermissions() {
      //inject here:all
      return rules;
    }

    function userTypeAnonymousPermissions() {
      //inject here:anonymous
      //Should return if the user is AT LEAST anonymous
      return loggedIn() ? rules : {};
    }

    function userTypeSignedInPermissions() {
      //inject here:signed_in
      return loggedIn() && !isAnonymous() ? rules : {};
    }

    function userTypeSignedInDomainPermissions() {
      //inject here:signed_in_domain
      return userMatchesDomain() ? rules : {};
    }

    function userPermissions() {
      return (request.auth != null && request.auth.uid != null && exists(/databases/$(database)/documents/permissions/$(request.auth.uid))) ? get(/databases/$(database)/documents/permissions/$(request.auth.uid)).data : {};
    }

    function getPermission(key) {
      return userPermissions().get(key, userTypeSignedInDomainPermissions().get(key, userTypeSignedInPermissions().get(key, baseUserTypeSignedInPermissions().get(key, userTypeAnonymousPermissions().get(key, baseUserTypeAnonymousPermissions().get(key, userTypeAllPermissions().get(key, basePermissions().get(key, false))))))));
    }

    function userIsAdmin() {
      //don't do the whole transform of getPermission, because admin is so sensitive that it should only be 
      //able to be set per user, and getPermission is really expensive to run twice
      return userPermissions().get('admin', false);
    }

    function userMayViewApp() {
      return userIsAdmin() || getPermission('viewApp');
    }
    
    function userMayViewUnpublished() {
      return userIsAdmin() || getPermission('viewUnpublished');
    }

    function userMayEditCard(cardID) {
      return userIsAdmin() || getPermission('edit') || request.auth.uid in get(/databases/$(database)/documents/cards/$(cardID)).data.editors;
    }

    function userMayComment() {
      return userIsAdmin() || getPermission('comment');
    }

    function userMayStar() {
      return userIsAdmin() || getPermission('star');
    }

    function userMayMarkRead() {
      return userIsAdmin() || getPermission('markRead');
    }

    function userMayModifyReadingList() {
      return userIsAdmin() || getPermission('modifyReadingList');
    }

    function editOnlyUpdatesTimestamp(key) {
      let requestData = request.resource.data;
      return requestData.diff(resource.data).affectedKeys().hasOnly([key]) && requestData[key] == request.time;
    }

    function editOnlyIncrementsAndUpdatesTimestamp(incrementKey, timestampKey) {
      let requestData = request.resource.data;
      let resourceData = resource.data;
      return requestData.diff(resourceData).affectedKeys().hasOnly([incrementKey, timestampKey]) && requestData[timestampKey] == request.time && resourceData[incrementKey] + 1 == requestData[incrementKey]
    }

    function editOnlyAddsMessage() {
      let requestData = request.resource.data;
      let requestMessages = requestData.messages;
      let resourceMessages = resource.data.messages;
      return requestData.diff(resource.data).affectedKeys().hasOnly(['messages', 'updated']) && requestMessages.size() == resourceMessages.size() + 1 && requestMessages[0:resourceMessages.size()] == resourceMessages;
    }
        
    function editOnlyIncrements(key) {
      let requestData = request.resource.data;
      let resourceData = resource.data;
      return requestData.diff(resourceData).affectedKeys().hasOnly([key]) && resourceData[key] + 1 == requestData[key];
    }
    
    function editOnlyIncrementsOrDecrements(key, otherKey) {
      let requestData = request.resource.data;
      let resourceData = resource.data;
      let resourceDataKey = resourceData[key];
      let requestDataKey = requestData[key];
      let resourceDataOtherKey = resourceData[otherKey];
      let requestDataOtherKey = requestData[otherKey];
      return requestData.diff(resourceData).affectedKeys().hasOnly([key, otherKey]) && (resourceDataKey + 1 == requestDataKey || resourceDataKey - 1 == requestDataKey) && (resourceDataOtherKey + 1 == requestDataOtherKey || resourceDataOtherKey - 1 == requestDataOtherKey);
     }
    
    function editOnlyIncrementsAndDecrements(incKey, decKey) {
      let requestData = request.resource.data;
      let resourceData = resource.data;
      return requestData.diff(resourceData).affectedKeys().hasOnly([incKey, decKey]) && resourceData[decKey] - 1 == requestData[decKey] && resourceData[incKey] + 1 == requestData[incKey];
    }

    function cardEditMinor() {
      let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
      //we can bail only if there are any keys not in this set, or if they aren't any keys in this set, without doing the more expensive calculations.
      let allKeys = ['star_count', 'star_count_manual', 'thread_count', 'thread_resolved_count', 'thread_count', 'updated_message'];
      return affectedKeys.hasOnly(allKeys) && affectedKeys.hasAny(allKeys) && cardEditLegalMessages(affectedKeys) || cardEditLegalStars(affectedKeys);
    }

    function cardEditLegalMessages(affectedKeys) {
      //TODO: pass in the affectedKeys into the children to save another calculation
      return userMayComment() && (editOnlyIncrements('thread_count') || editOnlyIncrementsAndDecrements('thread_resolved_count', 'thread_count') || editOnlyUpdatesTimestamp('updated_message') || editOnlyIncrementsAndUpdatesTimestamp('thread_count', 'updated_message'));
    }

    function cardEditLegalStars(affectedKeys) {
      //TODO: pass in the affectedKeys into the children to save another calculation
      return userMayStar() && editOnlyIncrementsOrDecrements('star_count', 'star_count_manual');
    }
    
    function loggedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isAnonymous() {
      return request.auth != null && request.auth.token != null && request.auth.token.firebase != null && request.auth.token.firebase.sign_in_provider == 'anonymous';
    }
    
    function createIsOwner() {
      return loggedIn() && request.auth.uid == request.resource.data.owner;
    }
    
    function createIsAuthor() {
      return loggedIn() && request.auth.uid == request.resource.data.author;
    }
    
    function updateIsOwner() {
      return loggedIn() && request.auth.uid == resource.data.owner;
    }
    
    function updateIsAuthor() {
      return loggedIn() && request.auth.uid == resource.data.author;
    }

    match /permissions/{user} {
      allow read: if request.auth.uid == user;
    }

    match /sections/{section} {
      allow read: if userMayViewApp();
      allow write: if userIsAdmin();

      match /updates/{update} {
        allow read, write: if userIsAdmin();
      }
    }

    match /tags/{tag} {
      allow read: if userMayViewApp();
      allow write: if userIsAdmin();

      match /updates/{update} {
        allow read, write: if userIsAdmin();
      }
    }
    
    match /authors/{author} {
      allow read: if userMayViewApp();
      //Allow authors to write their own author entry, or any admin to create a
      //stub placeholder to be filled in later. The user must be an admin
      //because a) they need to know the uid, which implies access to the
      //firebase auth console anyway, and secondarily, anyone who can edit any
      //card can note editors, and there's no good way to detect that, so this
      //would be left open to anyeone, which would mean anyone could compell a
      //user to divulge their displayName and photoURL to the public when they
      //next visited.
      allow create: if request.auth.uid == author || (userIsAdmin() && request.resource.data.size() == 0)
      allow write: if request.auth.uid == author || (userIsAdmin() && request.resource.data.diff(resource.data).affectedKeys().size() == 0);
    }

    match /users/{user} {
      allow read: if request.auth.uid == user;
      allow write: if request.auth.uid == user;
    }
    
    match /cards/{card} {
      allow read: if userMayViewApp() && (resource.data.published == true || userMayViewUnpublished());
      allow create: if userIsAdmin() && createIsAuthor();
      allow update: if cardEditMinor() || userMayEditCard(card);
    
      match /updates/{update} {
        allow read, write: if userMayEditCard(card);
      }
    }

    match /maintenance_tasks/{task} {
      allow read: if userIsAdmin();
      allow write: if userIsAdmin();
    }
    
    match /messages/{message} {
      allow read: if userMayViewApp();
      allow create: if createIsAuthor() && userMayComment();
      allow update: if (updateIsAuthor() || userIsAdmin()) && userMayComment();
    }
    
    match /threads/{thread} {
      allow read: if userMayViewApp();
      allow create: if createIsAuthor() && userMayComment()
      allow update: if userMayComment() && (updateIsAuthor() || (!isAnonymous() && editOnlyAddsMessage()) || userIsAdmin());
    }
    
    match /stars/{star} {
      allow create: if userMayStar() && createIsOwner();
      allow update: if userMayStar() && updateIsOwner();
      allow delete: if userMayStar() && updateIsOwner();
      allow read: if updateIsOwner();
    }

    match /reads/{read} {
      allow create: if userMayMarkRead() && createIsOwner();
      allow update: if userMayMarkRead() && updateIsOwner();
      allow delete: if userMayMarkRead() && updateIsOwner();
      allow read: if updateIsOwner();
    }

    match /tweets/{tweet} {
      allow read: if userMayViewApp();
    }

    match /reading_lists/{list_id} {
      allow create: if userMayModifyReadingList() && createIsOwner();
      allow update: if userMayModifyReadingList() && updateIsOwner();
      allow delete: if userMayModifyReadingList() && updateIsOwner();
      allow read: if updateIsOwner();

      match /updates/{update} {
        //Anyone can read or write the updates sub-collection as long as they're logged in as 
        //the ID of the reading_list, which is the same as the owner of the reading-list.
        allow read, write: if list_id == request.auth.uid;
      }
    }
  }
}
