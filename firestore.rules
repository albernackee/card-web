rules_version = '2'
service cloud.firestore {
  match /databases/{database}/documents {

    function userIsAdmin() {
      //Because we can't create a temporary variable we have to use both exists and get, because most users won't have a permissions object.
      return request.auth.uid != null && exists(/databases/$(database)/documents/permissions/$(request.auth.uid)) && get(/databases/$(database)/documents/permissions/$(request.auth.uid)).get(['data','admin'], false)
    }
    
    function editOnlyUpdatesTimestamp(key) {
      return request.writeFields.hasOnly([key]) && request.resource.data[key] == request.time;
    }

    function editOnlyIncrementsAndUpdatesTimestamp(incrementKey, timestampKey) {
      return request.writeFields.hasOnly([incrementKey, timestampKey]) && request.resource.data[timestampKey] == request.time && resource.data[incrementKey] + 1 == request.resource.data[incrementKey]
    }

    function editOnlyAddsMessage() {
      return request.writeFields.hasOnly(['messages', 'updated']) && request.resource.data.messages.size() == resource.data.messages.size() + 1 && request.resource.data.messages[0:resource.data.messages.size()] == resource.data.messages;
    }
        
    function editOnlyIncrements(key) {
      return request.writeFields.hasOnly([key]) && resource.data[key] + 1 == request.resource.data[key];
    }
    
    function editOnlyIncrementsOrDecrements(key) {
      return request.writeFields.hasOnly([key]) && (resource.data[key] + 1 == request.resource.data[key] || resource.data[key] - 1 == request.resource.data[key]);
    }
    
    function editOnlyIncrementsAndDecrements(incKey, decKey) {
      return request.writeFields.hasOnly([incKey, decKey]) && resource.data[decKey] - 1 == request.resource.data[decKey] && resource.data[incKey] + 1 == request.resource.data[incKey];
    }
    
    function loggedIn() {
      return request.auth.uid != null;
    }

    function isAnonymous() {
      return request.get(['auth', 'token', 'firebase', 'sign_in_provider'], 'google') == 'anonymous';
    }
    
    function createIsOwner() {
      return loggedIn() && request.auth.uid == request.resource.data.owner;
    }
    
    function createIsAuthor() {
      return loggedIn() && request.auth.uid == request.resource.data.author;
    }
    
    function updateIsOwner() {
      return loggedIn() && request.auth.uid == resource.data.owner;
    }
    
    function updateIsAuthor() {
      return loggedIn() && request.auth.uid == resource.data.author;
    }

    match /{document=**} {
      allow read: if userIsAdmin();
      allow write: if userIsAdmin();
    }

    match /permissions/{user} {
      allow read: if request.auth.uid == user;
    }

    match /sections/{section} {
      allow read: if true;
    }

    match /tags/{tag} {
      allow read: if true;
    }
    
    match /authors/{author} {
      allow read: if true;
      allow write: if request.auth.uid == author;
    }

    match /users/{user} {
      allow read: if request.auth.uid == user;
      allow write: if request.auth.uid == user;
    }
    
    match /cards/{card} {
      allow read: if true;
      allow update: if loggedIn() && (editOnlyIncrements('thread_count') || editOnlyIncrementsAndDecrements('thread_resolved_count', 'thread_count') || editOnlyIncrementsOrDecrements('star_count') || editOnlyUpdatesTimestamp('updated_message') || editOnlyIncrementsAndUpdatesTimestamp('thread_count', 'updated_message'));
    }
    
    match /messages/{message} {
      allow read: if true;
      allow create: if createIsAuthor() && !isAnonymous();
      allow update: if updateIsAuthor();
    }
    
    match /threads/{thread} {
      allow read: if true;
      allow create : if createIsAuthor() && !isAnonymous();
      allow update : if updateIsAuthor() || (loggedIn() && editOnlyAddsMessage());
    }
    
    match /stars/{star} {
      allow create: if createIsOwner();
      allow update: if updateIsOwner();
      allow delete: if updateIsOwner();
      allow read: if updateIsOwner();
    }

    match /reads/{read} {
      allow create: if createIsOwner();
      allow update: if updateIsOwner();
      allow delete: if updateIsOwner();
      allow read: if updateIsOwner();
    }

    match /tweets/{tweet} {
      allow read: if true;
    }

    match /reading_lists/{list_id} {
      allow create: if createIsOwner();
      allow update: if updateIsOwner();
      allow delete: if updateIsOwner();
      allow read: if updateIsOwner();

      match /updates/{update} {
        //Anyone can read or write the updates sub-collection as long as they're logged in as 
        //the ID of the reading_list, which is the same as the owner of the reading-list.
        allow read, write: if list_id == request.auth.uid;
      }
    }
  }
}
